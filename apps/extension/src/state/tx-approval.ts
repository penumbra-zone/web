import { AuthorizeRequest } from '@buf/penumbra-zone_penumbra.bufbuild_es/penumbra/custody/v1/custody_pb';
import type { Jsonified, Stringified, TransactionClassification } from '@penumbra-zone/types';
import { AllSlices, SliceCreator } from './index';
import { MessageResponder } from '@penumbra-zone/types/src/internal-msg/shared';
import { TxApproval } from '@penumbra-zone/types/src/internal-msg/tx-approval';
import { TransactionView } from '@buf/penumbra-zone_penumbra.bufbuild_es/penumbra/core/transaction/v1/transaction_pb';
import { Address } from '@buf/penumbra-zone_penumbra.bufbuild_es/penumbra/core/keys/v1/keys_pb';
import { viewClient } from '../clients/extension-page';

import {
  asPublicTransactionView,
  asReceiverTransactionView,
  classifyTransaction,
} from '@penumbra-zone/types';
import { JsonObject } from '@bufbuild/protobuf';
import { ConnectError } from '@connectrpc/connect';
export interface TxApprovalSlice {
  /**
   * Zustand doesn't like JsonValue, because the type is infinitely deep. And we
   * can't store instances of custom classes (like `TransactionView`s) in the
   * store, because we're using Immer middleware for Zustand, which requires
   * that everything be JSON-serializeable. So we'll store `Stringified`
   * representations of them instead.
   */
  responder?: MessageResponder<TxApproval>;
  authorizeRequest?: Stringified<AuthorizeRequest>;
  transactionView?: Stringified<TransactionView>;

  acceptRequest: (
    req: {
      authorizeRequest: Jsonified<AuthorizeRequest>;
      transactionView: Jsonified<TransactionView>;
    },
    responder: MessageResponder<TxApproval>,
  ) => Promise<void>;

  // these are generated by setTransactionView
  asSender?: Stringified<TransactionView>;
  asReceiver?: Stringified<TransactionView>;
  asPublic?: Stringified<TransactionView>;
  transactionClassification?: TransactionClassification;

  attitude?: boolean;
  setAttitude: (attitude: boolean) => void;

  sendResponse: () => void;
}

export const createTxApprovalSlice = (): SliceCreator<TxApprovalSlice> => (set, get) => ({
  acceptRequest: async (
    { authorizeRequest: authReqJson, transactionView: txViewJson },
    responder,
  ) => {
    const authorizeRequest = AuthorizeRequest.fromJson(authReqJson);
    const transactionView = TransactionView.fromJson(txViewJson);

    const asSender = transactionView;
    const asPublic = asPublicTransactionView(transactionView);
    const asReceiver = await asReceiverTransactionView(transactionView, {
      isControlledAddress,
    });

    set(state => {
      state.txApproval.responder = responder;
      state.txApproval.authorizeRequest = authorizeRequest.toJsonString();
      state.txApproval.transactionView = transactionView.toJsonString();

      state.txApproval.asSender = asSender.toJsonString();
      state.txApproval.asPublic = asPublic.toJsonString();
      state.txApproval.asReceiver = asReceiver.toJsonString();
      state.txApproval.transactionClassification = classifyTransaction(transactionView);

      state.txApproval.attitude = undefined;
    });
  },

  setAttitude: attitude => {
    set(state => {
      state.txApproval.attitude = attitude;
    });
  },

  sendResponse: () => {
    const {
      responder,
      attitude,
      transactionView: transactionViewString,
      authorizeRequest: authorizeRequestString,
    } = get().txApproval;
    try {
      if (!responder || attitude === undefined || !transactionViewString || !authorizeRequestString)
        throw new Error('Missing response data');

      responder({
        type: 'TX-APPROVAL',
        data: {
          attitude,
          transactionView: TransactionView.fromJsonString(
            transactionViewString,
          ).toJson() as JsonObject,
          authorizeRequest: AuthorizeRequest.fromJsonString(
            authorizeRequestString,
          ).toJson() as JsonObject,
        },
      });
    } catch (err) {
      if (responder)
        responder({
          type: 'TX-APPROVAL',
          error: ConnectError.from(err),
        });
      else throw err;
    } finally {
      set(state => {
        state.txApproval.responder = undefined;
        state.txApproval.authorizeRequest = undefined;
        state.txApproval.transactionView = undefined;
        state.txApproval.attitude = undefined;
      });
    }
  },
});

export const txApprovalSelector = (state: AllSlices) => state.txApproval;

/**
 * Returns a boolean indicating whether the given address is controlled by the
 * current user.
 *
 * @see packages/router/src/grpc/view-protocol-server/index-by-address.ts
 */
export const isControlledAddress = async (address: Address): Promise<boolean> => {
  const indexByAddressResponse = await viewClient.indexByAddress({ address });
  return Boolean(indexByAddressResponse.addressIndex);
};
